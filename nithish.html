<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="logo">City Design</div>
        <ul class="nav-links">
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="project.html">Project</a></li>
        </ul>
    </nav>

    <!-- Business Ideas Section -->
    <section class="business-ideas">
        <h2 class="head">Identified Business Ideas</h2>
        <div class="ideas-box">
            
            <div class="idea">
                <h3>Power Demand Analysis</h3>
                <p>
                    <ul>
                        <li>
                            <b>Relevance to SDG 7:</b> Efficient power demand analysis ensures that electricity supply meets demand without overproduction, reducing energy waste and costs.
                        </li>
                        <li>
                            This business idea involves using data analytics and machine learning to monitor and predict electricity demand in specific areas. Accurate forecasting can help utility companies optimize energy distribution, minimize blackouts, and improve grid stability.
                        </li>
                    </ul>
                </p>
            </div>

            <div class="idea">
                <h3>Renewable Energy Integration:</h3>
                <p>
                    <ul>
                        <li>
                            <b>Relevance to SDG 7:</b> Promoting the use of renewable energy sources reduces reliance on fossil fuels, leading to cleaner energy systems.
                        </li>
                        <li>
                            This idea focuses on integrating renewable energy (solar, wind, etc.) into the existing power grid. It could involve designing smart grid systems or microgrids that manage the variability of renewables while ensuring consistent energy supply to consumers.
                        </li>
                    </ul>
                </p>
            </div>

            <div class="idea">
                <h3>Energy Efficiency Management:</h3>
                <p>
                    <ul>
                        <li>
                            <b>Relevance to SDG 7:</b> Energy efficiency is critical to reducing energy consumption and associated costs while minimizing environmental impact.
                        </li>
                        <li>
                            This business idea revolves around technologies or strategies to optimize energy use in homes, businesses, and industries. Examples include energy-efficient appliances, smart meters, and AI-driven systems that detect and eliminate energy wastage.
                        </li>
                    </ul>
                </p>
            </div>
            
        </div>
    </section>

    <!-- Reflection Section -->
    <section class="Reflection">
        <h2>Course  Learning Reflections</h2>
        <div class="reflection-box">
            <ol>
                <li>
                    What are the kinds of problems we see in nature? (iteration, recursion, backtracking)
                    <p class="ans">
                        In nature, we can see problems being solved in ways similar to computational techniques like iteration, recursion, and backtracking. 
                        For example, iteration shows up in things like the repeating cycles of seasons or the rise and fall of predator-prey populations. 
                        Recursion is easy to spot in patterns like snowflakes, the way trees branch out, or how rivers split into smaller streams—all of them repeating the same shapes on different scales. 
                        Backtracking happens when animals, like ants or rats, try one path to find food, hit a dead end, and go back to try another. 
                        Nature uses these methods to adapt, solve problems, and make things work efficiently.
                    </p>
                </li>
                <li>
                    What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.
                    <p class="ans">
                        Space and time efficiency refer to how much memory it uses as the input size grows and how fast an algorithm runs. 
                        Time efficiency ensures the program runs quickly, while space efficiency focuses on saving memory, which is especially important in resource-limited environments. 
                        The different class of problem can be represented in form of graph as follows:
                        <br>
                            O(1): constant order of growth 
                        <br>
                            O(n): linear order of growth 
                        <br>
                            O(log n): logarithmic order of growth 
                        <br>
                            O(nlogn): Runtime increases more than linear but less than quadratic with input size.
                        <br>
                            O(n2): Runtime increases quadratically.
                        <br>
                            O(n3): Runtime increases cubic.
                        <br>
                            O(2^n): The runtime grows exponentially.
                        <br>
                            O(n!): The runtime grows extremely fast.
                    </p>
                </li>
                <li>
                    Take away from different design principles from chapter 2?
                    <p class="ans">
                        The key takeaway from the design principles is how simple strategies can make complex problems more manageable and algorithms more efficient. 
                        By using principles like decomposition, pattern recognition, and abstraction, we break down tasks into smaller parts. 
                        Techniques like pruning (in N-queens) and lazy propagation (in segment trees) optimize resource use, eliminating unnecessary steps or delaying updates until needed. 
                        Hierarchical order (in BST) and level order traversal (in BFS) help us process data effectively. 
                        Pre-computing results, like in lookup tables, simplifies repeated operations. 
                        Using parental dominance in heaps and bit manipulation in Fenwick trees speeds up calculations. 
                        Finally, DFS and BFS teach us to navigate graphs with careful traversal. 
                        All these principles combine to create more efficient algorithms.
                    </p>
                </li>
                <li>
                    The hierarchical data and how different tree data structures solve and optimize over problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)
                    <p class="ans">
                        Tree data structures are essential for organizing hierarchical data and optimizing operations like searching, sorting, and indexing. 
                        A general tree provides flexibility for generic hierarchies but lacks efficiency. 
                        Binary trees are foundational but can become inefficient if unbalanced. 
                        Self-balancing trees like AVL and Red-Black trees ensure \(O(\log n)\) operations, with AVL trees being more strictly balanced and Red-Black trees easier to maintain during frequent updates. 
                        Heaps are ideal for priority-based tasks (e.g., scheduling), while Tries excel in prefix searches and string operations, such as autocompletion. 
                        Multiway trees like 2-3 trees offer consistent balancing, making them perfect for databases and file systems. 
                        Each structure is tailored to specific scenarios, balancing trade-offs between speed, complexity, and memory usage.
                    </p>
                </li>
                <li>
                    The need for array query algorithms and their implications. Their applications and principles need to be discussed.
                    <p class="ans">
                        Array query algorithms are essential for quickly answering questions about data, such as range sums, maximum values, or patterns, especially in large datasets. 
                        They balance preprocessing, memory usage, and query speed to handle real-time applications like databases, gaming, analytics, and machine learning. 
                        Techniques like prefix sums, Fenwick trees, segment trees, and sliding windows are widely used to optimize operations, ensuring fast responses and efficient updates. 
                        These algorithms are foundational for modern systems where scalability and performance are critical.
                    </p>
                </li>
                <li>
                    Differentiate between tree and graphs and their traversals. The applications of each.
                    <p class="ans">
                        Tree <br>
                        -A connected, acyclic graph with n nodes and n-1 edges. <br>
                        -always has a root node. <br>
                        -always connected. <br>
                        -no cycles. <br>
                        
                       <br> Graphs <br>
                        -Collection of vertices connected by edges, cyclic and even disconnected. <br>
                        -no specific root unless mentioned. <br>
                        -can be connected or disconnected. <br>
                        -have cycles. <br>
                        
                        <br> Tree traversals <br>
                        1. Pre order: Root,Left,Right <br>
                        2. In order: Left, Root, Right <br>
                        3. Post order: Left, Right, Root <br>
                        <br> Eg: heap, BST for search, insert, delete <br>
                        
                        <br> Graph Traversals <br>
                       <br> DFS: traverse as deep as possible before backtracking. <br>
                         Eg: Road maps, Invitation problem. <br>
                        
                       <br> BFS: visit all neighbour nodes before moving. <br>
                        Eg: Networks (social networks)
                    </p>
                </li>
                <li>
                    Deliberate on sorting and searching algorithms, the technique behind each and how they connect to the real world.
                    <p class="ans">
                        Sorting and searching algorithms are vital for organizing and retrieving data efficiently. 
                        Sorting arranges data in a specific order, using techniques like quicksort for speed or counting sort for specific cases, while searching locates items, with binary search excelling on sorted datasets. 
                        These algorithms power real-world applications like search engines, e-commerce filters, and route planning, ensuring quick and reliable results. 
                        Together, they enable efficient data handling, forming the backbone of modern systems like databases, AI, and analytics.
                    </p>
                </li>
                <li>
                    Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.
                    <p class="ans">
                        Graph algorithms, especially for spanning trees and shortest paths, are essential for optimizing real-world systems like networks, navigation, and logistics. 
                        Spanning tree algorithms help efficiently connect all nodes with minimal cost, making them crucial for network design and broadcasting. 
                        Shortest path algorithms, like Dijkstra’s, are used to find the fastest or most cost-effective route, impacting applications like GPS navigation, data routing, and supply chain management. 
                        Together, these algorithms ensure efficient and cost-effective connectivity in fields like telecommunications, transportation, and resource management.
                    </p>
                </li>
                <li>
                    Discuss the different studied algorithm design techniques.
                    <p class="ans">
                        In class, we explored several design techniques, starting with backtracking, where we solved problems like the n-queens and subset generation by considering all possibilities and eliminating unnecessary ones. 
                        We also learned about transform and conquer with AVL trees, heaps, and 2-3 trees. 
                        Moving on to decrease and conquer, we studied graph traversals like BFS and DFS. 
                        We covered divide and conquer through sorting algorithms and string matching techniques, including the Boyer-Moore algorithm, which uses space and time trade-offs. 
                        Finally, we explored greedy algorithms, such as Prim’s, Kruskal’s, and Dijkstra’s, to find the shortest path in weighted graphs.
                    </p>
                </li>
            </ol>
        </div>
    </section>

    <section class="case-breakdown">
        <h2 class="breakdown-head">Detailed Breakdown Of Business Ideas</h2>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Affordable Clean Energy Solutions</h2>
                <p class="explain">
                    <ul>
                        <li>
                            Providing Affordable Clean Energy Solutions is 
                            necessary for a developing city as it promotes 
                            sustainable development and reduces the dependency
                             on fossil fuels. This also supports economic growth
                            by creating job opportunities and provides a reliable, 
                            long term cost efficient source of energy.  

                        </li>
                        <li>
                            For implementing an Affordable Clean Energy Solutions business, 
                            there are various different algorithms that can be used to make 
                            the business run more efficiently. We can represent the whole distribution
                            network as a graph with nodes as power grids and houses to which the energy 
                            must be supplied, and the routes for this transmission are the edges.
                        </li>
                        <li>
                            We can make use of <b>Prim's algorithm</b> to find the MST (minimum spanning tree) to 
                            lay down the routes for energy distribution at the lowest cost possible. We are 
                            using Prim's over Kruskal's as the graph network with the edges as cables between 
                            the houses and power grids is dense with many cables (edges) hence, Prim's is a better
                             algorithm to find the MST in a dense graph.
                        </li>
                        <li>
                            Next, we can use shortest path algorithms like <b>Dijkstra's algorithm</b> to optimize the location 
                            of the power grids, and for efficient distribution of energy to all the houses, we can take the
                            main power station as the source node and apply Dijkstra's on the graph representation to find 
                            the shortest paths to distribute the energy from the source.
                        </li>
                        <li>
                            We can also use <b>sorting algorithms</b> to sort the areas based on the populations so that we can place
                             an appropriately sized grid based on the population.
                        </li>
                        <li>
                            A <b>look-up table</b> is a data structure that stores pre-computed values for fast retrieval. 
                            This can be used to quickly access large amounts of data in the case of an energy distribution system. 
                            It can be used to retrieve the energy consumption data of a particular consumer or a building. 
                        </li>
                        <li>
                            <b>BIT or Fenwick tree</b> works on the concept of isolating the last bit and is efficient in the case of range queries.
                            We are using BIT over segment trees as BIT is easier t implement due to its simple code.
                            BIT can be used to calculate the total energy consumption of a consumer over a specific time period.  
                        </li>
                    </ul>
                    <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Prim's Algorithm</b>
                            <p>Prim's Algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) 
                                of a connected, undirected graph with weighted edges<br>
                                Efficiency: O(|E|log|V|)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Prims%20Algorithm" class="code">Sample Code for Prim's Algorithm</a>
                            </p>
                        </li>
                        <li><b>Dijkstra's algorithm</b>
                            <p>Dijkstra's Algorithm is a well-known greedy algorithm used for finding the shortest path 
                                from a source vertex to all other vertices in a weighted graph (where the weights are non-negative).<br>
                                Efficiency: O(|E|log|V|)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Dijkstras%20Algorithm" class="code">Sample Code for Dijkstra's algorithm</a>
                            </p>
                        </li>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to arrange elements in a specific order 
                                (usually in ascending or descending order). <br>
                                Efficiency: <br>
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Lookup table</b>
                            <p>
                                A lookup table is a data structure that is used to store pre-computed values for quick retrieval. <br>
                                Efficiency: O(1)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Lookup-Table" class="code">Sample Code for Lookup table</a>
                            </p>
                        </li>
                        <li><b>BIT or Fenwick tree</b>
                            <p>BIT or Fenwick tree works on the concept of isolating the last bit and is 
                                efficient in processing of range queries. <br>
                                Efficiency: O(log n) <br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Fenwick%20Tree" class="code">Sample Code for BIT</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>

        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Education & Vocational Training Centers</h2>
                <p class="explain">
                    <ul>
                        <li>
                            As the city aims to become a self-sufficient, sustainable, and developed city, 
                            educational institutions play an important role in this process. For this, it is 
                            important to set up educational institutions across the entire city in such a way 
                            that they are accessible to all the people.
                        </li>
                        <li>
                            To achieve this, we will first analyze the total number of eligible students/people 
                            who will access these educational institutions. This can be done using a <b>basic summation algorithm</b>. 
                            The next step is to arrange the areas based on the number of people who will be accessing these institutions,
                             which can be done using sorting algorithms such as <b>quick sort and merge sort</b>.

                        </li>
                        <li>Once we have sorted the areas based on population, we can finalize the locations and sizes of these institutions.
                             The size of an institution will depend on the number of people attending it. Hence, larger institutions will be set 
                             up in more populated areas based on the sorted list.
                        </li>
                        <li>The next step is to strategically select the locations of the institutions to ensure that they do not cause any harm to
                             the environment in the process of building it. After selecting the locations for the educational institutions, the next 
                             task is to set up a bus or pickup/drop service for all the students attending these institutions.
                        </li>
                        <li>For this, we need to design an efficient and cost-saving route for the buses to drop each student at their home. 
                            This can be done using an <b>all-pairs shortest path algorithm like Floyd's algorithm.</b> We can consider the institution
                             and the homes of each student as the nodes, and the roads connecting these areas as the edges, with weights as the travel cost.
                              By applying <b>Floyd's algorithm</b> to this graph representation, we can design the most efficient route for dropping off each student.
                        </li>
                        <li>Now that we have set up institutions in strategic locations accessible to all, it is important for these institutions to function in an 
                            organized manner to ensure a smooth and hassle-free experience. To achieve this, we need to keep a record of each student. This can be done
                             using an <b>array of structures</b> to store student information such as name, roll number, contact details, etc.
                        </li>
                        <li>For the admission process, we can use a <b>queue data structure</b> to provide admission on a first-come, first-served basis. Alternatively, we can 
                            sort the students based on their marks using a <b>sorting technique</b> and then provide admission based on the marks obtained by each student.
                        </li>
                        <li>
                            Other sensitive data regarding students, such as their Aadhaar number or parents' bank details, can be stored securely using <b>hashing algorithms.</b>
                        </li>
                    </ul>
                    <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Basic summation algorithm</b>
                            <p>Calculates the sum of all the elements of an Array.
                                Efficiency: O(1)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/blob/d85d72bbe8b0fc7c430c855b9b817b860b716ead/Basic%20Operations/Sum%20of%20elements%20of%20Array.cpp" class="code">Sample Code for Basic summation</a>
                            </p>
                        </li>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to arrange elements 
                                in a specific order (usually in ascending or descending order).<br>
                                Efficiency: 
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Floyd's algorithm</b>
                            <p>The Floyd-Warshall algorithm is an algorithm used to find the shortest paths 
                                between all pairs of nodes in a weighted graph.<br>
                                Efficiency: O(n^3)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Floyds%20Algorithm" class="code">Sample Code for Floyd's algorithm</a>
                            </p>
                        </li>
                        <li><b>Array of structures</b>
                            <p>An array of structures is a collection of multiple structure variables stored sequentially in memory.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/590680d9c376432fa276ad23a0e4fb9afe55d950/Array%20Of%20Structures" class="code">Sample Code for Array of structures</a>
                            </p>
                        </li>
                        <li><b>Queue data structure</b>
                            <p>A queue is a linear data structure that follows the FIFO (First In, First Out) principle. This means that 
                                the element added first will be removed first.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/33727621bd6560be47e0cb784cdc14957225b16d/Queue" class="code">Sample Code for Basic Queue</a>
                            </p>
                        </li>
                        <li><b>Hashing algorithms</b>
                            <p>Hashing algorithms are methods used to map data (such as a string, number, or any type of object) to a fixed-size 
                                value called a hash value.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/33727621bd6560be47e0cb784cdc14957225b16d/Hashing" class="code">Sample Code for Hashing algorithms</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>

        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Microfinance or Lending Services</h2>
                <p>Micro-financing and lending services play an important role in the development of a city. They help people with low incomes access financial resources for housing improvements or purchases. This leads to the overall development of infrastructure in the city.

                    To implement this, we first need to store all the customer data,
                     for which we can use an <b>array of structures.</b> To ensure the correct
                      order of loan distribution, we can use <b>priority queues based on heaps,</b> 
                       distributing loans based on the urgency of the requirement. Another important
                        factor to consider is the credit scores, which determine whether loans are approved.
                         This can be done using <b>sorting algorithms</b> to sort the list based on credit scores.Further <b>hashing</b> can be used to store sensitive customer data securely.
                         <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to 
                                arrange elements in a specific order (usually in ascending or descending order).<br>
                                Efficiency:<br>
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Array of structures</b>
                            <p>An array of structures is a collection of multiple structure variables stored sequentially in memory.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/590680d9c376432fa276ad23a0e4fb9afe55d950/Array%20Of%20Structures" class="code">Sample Code for Array of structures</a>
                            </p>
                        </li>
                        <li><b>Priority Queues</b>
                            <p>
                                A Priority Queue (PQ) is a type of data structure that stores elements with associated priorities. 
                                In a priority queue, each element has a priority value, and the element with the highest priority is
                                 dequeued first<br>
                                 Efficiency: O(log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/33727621bd6560be47e0cb784cdc14957225b16d/Priority%20Queue" class="code">Sample Code for Priority Queue</a>
                            </p>
                        </li>
                        <li><b>Hashing algorithms</b>
                            <p>Hashing algorithms are methods used to map data (such as a string, number, or any type of object) 
                                to a fixed-size value called a hash value<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/33727621bd6560be47e0cb784cdc14957225b16d/Hashing" class="code">Sample Code for Hashing algorithm</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>
        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">E-commerce & Online Marketplaces</h2>
                <p class="explain">
                    <ul>
                        <li>
                            E-commerce and online marketplaces play an important role 
                            in boosting the economy of a city. They also make the lives of 
                            people easier by providing doorstep deliveries. There are various
                             algorithms that can be used to implement an online e-commerce 
                             marketplace. 
                        </li>
                        <li>
                            Firstly, we can use <b>binary search</b> to search for products from a list of different products. We can also use tries for the autocomplete feature during typing in the search bar.
                        </li>
                        <li>
                            We can use <b>string matching algorithms like KMP and Rabin-Karp</b> to 
                            search for names of the products efficiently in the database. The 
                            next thing is that we can use <b>sorting algorithms</b> to sort the products
                             based on prices, ratings, and popularity. We can use <b>recommendation
                                engines</b> to recommend products to users based on their previous 
                              purchases or viewed products. 
                        </li>
                        <li>
                            Lastly, at the time of delivery, we can use shortest path algorithms like 
                            <b>Dijkstra’s Algorithm</b> to optimize delivery routes. This can be done by
                             considering the storage hub as the source node where all the products 
                             have been collected from different parts of the country and are ready
                              to be set out for delivery. The other nodes are the houses of the 
                              customers to whom the products need to be delivered. The routes
                               joining them are the edges, with weights as the cost of travel. 
                        </li>
                        <li>
                            Now, by using <b>Dijkstra’s Algorithm</b>, we find the most efficient route to 
                            deliver the products to the customers' houses.
                        </li>
                        <li><b>Arrays and lists</b> can be used for storing product lists, order details, user carts, or customer feedback.

                        </li>
                        <li><b>Stack </b>can be used to keep track of undo actions in the shopping cart and for implementing backtracking </li>
                        <li><b>Union-Find </b> can be used for managing user groups or authentication-related tasks.</li>
                    </ul>
                    <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Binary Search</b>
                            <p>Binary Search is an efficient algorithm for finding an item from a sorted list or array. <br>
                                Efficiency:
                                Best case: O(1)<br>
                                Worst case & Avg case: O(log n)<br><br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Binary%20Search" class="code">Sample Code for Binary Search</a>
                            </p>
                        </li>
                        <li><b>String Search:- KMP & Rabin Karp</b>
                            <p>String search algorithms are used to find a substring or pattern inside a string or text.<br>
                                Efficiency:
                                KMP:<br>
                                Best case:<br>
                                Avg case:<br>
                                worst case:<br><br>
                                Rabin Karp:<br>
                                Best case:<br>
                                Avg case:<br>
                                worst case:<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/String%20Search" class="code">Sample Code for String Search</a>
                            </p>
                        </li>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to arrange elements in
                                a specific order (usually in ascending or descending order).<br>
                                Efficiency: <br>
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Recommendation engines</b>
                            <p>A recommendation engine (or recommendation system) is a type of software system that 
                                suggests products, services, or content to users based on their preferences, behavior, or other data. <br><br>
                                <a href="#kruskals" class="code">Sample Code for Recommendation engines</a>
                            </p>
                        </li>
                        <li><b>Trie</b>
                            <p>A Trie is a specialized tree-like data structure used for dealing with applications involving search operations
                                 like autocomplete, dictionary lookups, and spell checking.<br>
                                Efficiency: O(l) where l is length of string.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Trie" class="code">Sample Code for Trie</a>
                            </p>
                        </li>
                        <li><b>Dijkstra's algorithm</b>
                            <p>Dijkstra's Algorithm is a well-known greedy algorithm used for finding the shortest path 
                                from a source vertex to all other vertices in a weighted graph (where the weights are non-negative).<br>
                                Efficiency: O(|E|log|V|)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Dijkstras%20Algorithm" class="code">Sample Code for Dijkstra's algorithm</a>
                            </p>
                        </li>
                        <li><b>Arrays & Lists</b>
                            <p>An array is a collection of elements, typically of the same type, stored in contiguous memory locations. 
                                A list is a more flexible data structure than an array, often allowing for dynamic resizing. Lists can 
                                store elements of different types<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Linked%20List" class="code">Sample Code for Arrays & lists</a>
                            </p>
                        </li>
                        <li><b>Stack</b>
                            <p>A stack is a linear data structure that follows the Last In, First Out (LIFO) principle, meaning the last element added to the stack is the first one to be removed. <br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Stack" class="code">Sample Code for Stack</a>
                            </p>
                        </li>
                        <li><b>Union-Find</b>
                            <p>The Union-Find structure is particularly useful in applications where you need to efficiently manage and query dynamic connectivity, such as in graph algorithms 
                                e.g: Kruskal's Minimum Spanning Tree algorithm and in network connectivity problems.<br>
                                Efficiency: O(n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Unioin-Find" class="code">Sample Code for Union-Find</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>
        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Telecommunications Services</h2>
                <p class="explain">
                    <ul>
                        <li>
                            The first step is to identify the population density of each area.
                             This can be achieved using sorting techniques, such as <b>merge sort 
                                or quick sort</b>, to arrange the areas based on their population densities.
                              Once the areas are sorted, telecommunication towers can be strategically 
                              placed in locations that maximize network coverage, ensuring the towers
                               provide service to as many people as possible. 

                        </li>
                        <li>
                            After placing the towers, the next step is to connect them to houses and other
                             towers through fiber optic cables. To do this efficiently, <b>Kruskal’s algorithm</b>
                              can be used to find the Minimum Spanning Tree . The MST helps connect all
                               nodes with the minimum total cost, reducing the expenses for laying cables.
                        </li>
                        <li>
                            To manage the flow of messages , a <b>queue data structure</b> can be implemented. 
                            Queues process messages in the order they are received , such that the sequence 
                            of messages is maintained. This structure helps to organize message transfer 
                            efficiently without delays or reordering.
                        </li>
                        <li>
                            To protect the messages being transmitted across the network,<b> hashing </b>can be applied,
                            by assigning a unique hash value to each message. This ensures that the message are transferred securely . 
                        </li>
                    </ul>
                    <ul>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to arrange elements in a 
                                specific order (usually in ascending or descending order).<br>
                                Efficiency:
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Queue Data structure</b>
                            <p>A queue is a linear data structure that follows the FIFO (First In, First Out) principle. This means that the element added first will be removed first.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Queue" class="code">Sample Code for Queue</a>
                            </p>
                        </li>
                        <li><b>Kruskal’s algorithm</b>
                            <p>Kruskal's algorithm is a well-known greedy algorithm used to find the Minimum Spanning Tree (MST) 
                                of a connected, undirected graph.<br>
                                
                                Efficiency:<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Kruskal's%20Algorithm" class="code">Sample Code for Kruskal’s algorithm</a>
                            </p>
                        </li>
                        <li><b>Hashing algorithms</b>
                            <p>Hashing algorithms are methods used to map data (such as a string, number, or any type of object) 
                                to a fixed-size value called a hash value<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Hashing" class="code">Sample Code for Hashing algorithm</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>
        </div>
        <br>
    </section>
    <section class="FHcase">
        <h2 class="FHhead">Implemtation With File Handling</h2>
        <div class="FHbox">
            <h2>Education & Vocational Training Centers</h2>
            <ul>
                <li>Calculating Population of each Area<br><br>
                    <a href="https://github.com/AmoghPai19/CityPlan_Indraprasth.gitub.io/tree/3d056a2d1b85387eb12f49d0e7b8da97a1ad2805/Codes%20Using%20File-Handling/Amogh/Educational%20Institutions/PopulationCalc" class="code">Population Calculation</a><br><br>
                </li>
                <li>Sorting the areas based on the population<br><br>
                    <a href="https://github.com/AmoghPai19/CityPlan_Indraprasth.gitub.io/tree/3d056a2d1b85387eb12f49d0e7b8da97a1ad2805/Codes%20Using%20File-Handling/Amogh/Educational%20Institutions/Sorting" class="code">Area Sorting</a><br><br>
                </li>
                <li>Pick-N-Drop Service<br><br>
                    <a href="https://github.com/AmoghPai19/CityPlan_Indraprasth.gitub.io/tree/3d056a2d1b85387eb12f49d0e7b8da97a1ad2805/Codes%20Using%20File-Handling/Amogh/Educational%20Institutions/Pick-N-Drop%20Service" class="code">Route Calculation</a><br><br>

                </li>
                <li>
                    Student Admission<br><br>
                    <a href="https://github.com/AmoghPai19/CityPlan_Indraprasth.gitub.io/tree/3d056a2d1b85387eb12f49d0e7b8da97a1ad2805/Codes%20Using%20File-Handling/Amogh/Educational%20Institutions/Admissions" class="code">Admission Queue</a><br><br>
                </li>
                <li>
                    Student information storage<br><br>
                    <a href="https://github.com/AmoghPai19/CityPlan_Indraprasth.gitub.io/tree/3d056a2d1b85387eb12f49d0e7b8da97a1ad2805/Codes%20Using%20File-Handling/Amogh/Educational%20Institutions/StudentInfo" class="code">Student structure</a><br><br>
                </li>
            </ul>
        </div>
        

    </section>
</body>
</html>
