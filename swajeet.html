<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="logo">City Design</div>
        <ul class="nav-links">
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="project.html">Project</a></li>
        </ul>
    </nav>

    <!-- Business Ideas Section -->
    <section class="business-ideas">
        <h2 class="head">Identified Business Ideas</h2>
        <div class="ideas-box">
            
            <div class="idea">
                <h3>Dynamic Power Management:</h3>
                <p>
                    <ul>
                        <li>
                            <b>Relevance to SDG 7:</b> Affordable and Clean Energy by improving energy efficiency and promoting sustainable energy usage.
                        </li>
                        <li>
                      This business idea involves around developing smart energy management systems for homes and businesses, utilizing IoT and AI to optimize energy consumption, reduce costs, and support sustainable operations.
                        </li>
                    </ul>
                </p>
            </div>

            <div class="idea">
                <h3>Efficient electricity distribution:</h3>
                <p>
                    <ul>
                        <li>
                            <b>Relevance to SDG 9:</b> Optimizing electricity distribution ensures reliable energy access, reduces wastage, and supports sustainable development goals.
                        </li>
                        <li>
                          Develop a business that provides smart grid solutions to optimize electricity distribution, reduce losses, and improve reliability for utility companies and large-scale consumers.
                        </li>
                    </ul>
                </p>
            </div>

            <div class="idea">
                <h3>Energy Storage Optimization:</h3>
                <p>
                    <ul>
                        <li>
                            <b>Relevance to SDG 7:</b> Optimizing energy storage improves grid stability, enhances renewable energy usage, and reduces dependency on nonrenewable sources.
                        </li>
                        <li>
                            Create a business offering advanced energy storage solutions for homes and businesses, optimizing energy use and promoting sustainability through efficient storage systems.
                        </li>
                    </ul>
                </p>
            </div>
            
        </div>
    </section>

    <!-- Reflection Section -->
    <section class="Reflection">
        <h2>Course  Learning Reflections</h2>
        <div class="reflection-box">
            <ol>
                <li>
                    What are the kinds of problems we see in nature? (iteration, recursion, backtracking)
                    <p class="ans">
                       <br>Nature presents numerous complex problems, many of which can be solved through computational techniques.
                        The life cycle and food chain are examples of processes that can be modeled using recursion.
                        <br>
                        Predicting climate change, on the other hand, is best tackled with iteration due to its dynamic, evolving patterns.
                         Bees, using backtracking, efficiently find the optimal foraging paths, ensuring maximum resource acquisition.
                        <br>
                        Similarly, plants exhibit self-organizing behavior, adjusting their growth patterns through backtracking to maximize sun exposure.
                        These natural processes, when modeled computationally, provide valuable insights into optimization and problem-solving techniques in real-world applications.
                    </p>
                </li>
                <li>
                    What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.
                    <p class="ans">
                        <br>
                        Time efficiency refers to how quickly an algorithm executes, while space efficiency measures the additional memory required during execution. Time efficiency is crucial in real-world applications, where faster algorithms are preferred. Space efficiency ensures optimal resource utilization, maximizing performance with minimal resources. 
                        <br>
                        - **O(1)**: Constant time complexity.
                        <br>
                            - **O(n)**: Linear time complexity.
                        <br>
                            - **O(log n)**: Logarithmic time complexity.
                        <br>
                            - **O(n log n)**: Slightly more than linear time, less than quadratic.
                        <br> 
                            -**O(n²)**: Quadratic time complexity.
                        <br>
                            - **O(n³)**: Cubic time complexity.
                        <br>
                            - **O(2^n)**: Exponential time complexity.
                        <br>
                            - **O(n!)**: Factorial time complexity, grows extremely fast.
                    </p>
                </li>
                <li>
                    Take away from different design principles from chapter 2?
                    <p class="ans"> 
                    <br>
                        The key takeaway from design principles is how simple concepts simplify complex problems, making algorithms more efficient.
                        We break down problems using decomposition, pattern recognition, and abstraction to manage tasks effectively. 
                    <br>
                        Pruning (used in N-queens) and lazy propagation (used in segment trees) optimize resource usage. Pruning eliminates non-viable solutions, while lazy propagation delays updates until necessary. 
                    Hierarchical order (BST) and level-order traversal (BFS) aid in data processing. Pre-computing (lookup tables) simplifies problems by storing results of frequent operations. 
                    <br>
                    Heaps use parental dominance to maintain efficiency. Bit manipulation (Fenwick tree) speeds up computations. DFS and BFS implement brave and cautious traversal for effective graph navigation. Overall, these principles create efficient algorithms.
                </li>
                <li>
                    The hierarchical data and how different tree data structures solve and optimize over problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)
                    <p class="ans">
                        <br>
                        A binary search tree efficiently supports operations like searching and insertion. 2-3 trees maintain balanced depth, ensuring optimal performance. AVL trees are self-balancing, automatically adjusting to maintain balance during insertions and deletions. 
                        Red-black trees balance themselves using color coding, ensuring efficient operations. Heaps maintain parental dominance, making deletions quick and efficient.
                        <br>
                        Tries optimize search performance by using prefix-based searches, enabling fast lookups in applications like autocomplete and dictionary searches. 
                        Each of these data structures offers unique advantages, contributing to the overall efficiency and effectiveness of algorithmic solutions.
                </li>
                <li>
                    The need for array query algorithms and their implications. Their applications and principles need to be discussed.
                    <p class="ans">
                        <br>
                        Array query algorithms are essential for efficiently searching, updating, and querying elements in an array, especially when dealing with large datasets. These algorithms are crucial for accessing data within specific intervals and ensuring quick responses for range-based queries.
                        <br>
                        Lookup Tables: A lookup table is a data structure used to efficiently answer range queries in a dataset. It pre-computes values such as minimum, maximum, or sum for various intervals. By storing these results, lookup tables save computation time during repeated queries, utilizing the concept of pre-computing for faster access.
                        <br>
                        Segment Trees: Segment trees divide an array into segments and represent it as a binary tree using a bottom-up approach. They are particularly effective for range queries and updates. Segment trees utilize the principle of lazy propagation, storing changes and only applying them when needed, optimizing performance and reducing unnecessary updates.
                        <br>
                        Sparse Tables: Sparse tables are designed for fast querying of static data. They preprocess the data, allowing for efficient range queries, particularly useful for minimum or maximum queries on immutable datasets. The preprocessing ensures that subsequent queries can be answered in constant time.
                        <br>
                        Fenwick Trees (Binary Indexed Trees): Fenwick trees are used for efficient computation of cumulative sums, minimums, or maximums over ranges of elements. Each node in a Fenwick tree stores information about a specific range, enabling fast updates and queries. The core principle used is bit manipulation, which helps in efficiently navigating the tree structure for quick computations</p>
                </li>
                <li>
                    Differentiate between tree and graphs and their traversals. The applications of each.
                    <p class="ans">
                        Trees and graphs are data structures that organize data differently. A tree is a hierarchical structure with a single root and no cycles, ideal for representing relationships like family trees or organizational charts. 
                        A graph consists of nodes connected by edges and can have cycles, making it suitable for networks, social connections, or road maps.
                        <br>
                        ->Tree Traversal:
                        <br>
                        1. Pre-order: Visit the root node first, then traverse the left subtree, followed by the right subtree.
                        <br>
                        2. In-order: Traverse the left subtree first, then visit the root node, and finally, traverse the right subtree.
                        <br>
                        3. Post-order: Traverse the left subtree first, then the right subtree, and visit the root node last.
                        <br>
                        ->Graph Traversal:
                        <br>
                        1. DFS (Depth First Search): A "brave" traversal method that explores as far down a branch as possible before backtracking.
                        <br>
                        2. BFS (Breadth First Search): A "cautious" traversal method that explores all neighbors of a node before moving to the next level.
                        <br>
                        ->Applications of Trees and Graphs:
                        <br>
                        1. Trees: Used for representing hierarchical data, such as file systems, organizational charts, and decision trees. They are also efficient for searching and sorting (e.g., binary search trees).
                        <br>
                        2. Graphs: Ideal for applications that require finding the shortest path, such as network routing, social media connections, or transportation maps. Graph algorithms like Dijkstra’s or A* are commonly used to solve pathfinding problems.
                </li>
                <li>
                    Deliberate on sorting and searching algorithms, the technique behind each and how they connect to the real world.
                    <p class="ans">
                        Sorting and searching algorithms are essential for efficiently managing and retrieving data.
                        <br>
                        ->Sorting Algorithms:
                        <br>
                        ⸳Bubble Sort: Compares and swaps adjacent elements, but is inefficient for large datasets.
                        <br>
                        ⸳Selection Sort: Improves on bubble sort by swapping only the minimum element in each pass.
                        <br>
                        ⸳Insertion Sort: Inserts elements in the correct position, effective for small or partially sorted data.
                        <br>
                        ⸳Merge Sort and Quick Sort: Both use the divide-and-conquer principle, dividing data into smaller parts and sorting them, offering better efficiency with O(n log n) time complexity.
                        <br>
                        ⸳Heap Sort: Builds a heap and sorts by repeatedly extracting the maximum or minimum element, also with O(n log n) time complexity.
                        <br>
                        ->Searching Algorithms:
                        <br>
                        ⸳Linear Search: Checks each element sequentially, suitable for unsorted or small datasets.
                        <br>
                        ⸳Binary Search: Efficiently searches sorted data by dividing the dataset in half, with a time complexity of O(log n).
                        <br>
                        ->Real-World Applications:
                        Sorting and searching algorithms are used in various applications like sorting product listings, ranking search results, filtering preferences, and quickly retrieving information from large datasets, such as in e-commerce platforms, search engines, and data analysis.
                </li>
                <li>
                    Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.
                    <p class="ans">
                        Graph algorithms are essential for solving optimization problems, especially when it comes to minimizing traversal costs. Algorithms like Kruskal's and Prim's are used to find the minimum spanning tree, which reduces the cost of traversal. 
                        These are applied in real-world scenarios such as laying cables, pipelines, and developing networks. For navigating the shortest path, algorithms like Dijkstra's and Floyd-Warshall are used, which are crucial for network routing, mapping, and navigation. 
                        By leveraging spanning trees and shortest path algorithms, we can enhance efficiency and reduce costs in various applications.
                </li>
                <li>
                    Discuss the different studied algorithm design techniques.
                    <p class="ans">
                        In class, we first learned about the design technique of backtracking, which involves solving problems like the N-Queens problem and subset generation. We explore all possible solutions and eliminate those that aren’t needed. 
                        Along with this, we studied transform and conquer, where we learned about data structures like AVL trees, heaps, and 2-3 trees that help in optimizing solutions.
                        <br>
                        Next, we encountered the decrease and conquer technique, especially in graph traversal. There are two main ways to traverse a graph:
                        <br>
                        -Breadth-First Search (BFS), where we visit all the nodes directly connected to the source first and then move on to the next level of nodes.
                        <br>
                        -Depth-First Search (DFS), where we explore one path fully before backtracking to explore other paths.
                        <br>
                        We also looked at divide and conquer in sorting algorithms, where we break the problem into smaller parts, solve each, and then combine the results. In string matching, we explored design principles like brute-force, hashing, and algorithms like Boyer-Moore, which balance space and time efficiently. 
                        Finally, we studied greedy algorithms, such as Prim’s, Kruskal’s, and Dijkstra’s, to find the shortest path in a weighted graph.
                        <br>
                        This approach simplifies complex problems by breaking them down into manageable parts and choosing the most efficient solutions.
                </li>
            </ol>
        </div>
    </section>

    <section class="case-breakdown">
        <h2 class="breakdown-head">Detailed Breakdown Of Business Ideas</h2>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Dynamic power management.</h2>
                <p class="explain">
                    <ul>
                        <li>
                            Ensuring efficient power management is crucial for a growing city as it supports sustainable development and decreases reliance on non-renewable energy sources. 
                            It fosters economic progress by generating employment opportunities and provides a dependable, long-term, cost-effective energy solution.  
                        </li>
                        <li>
                            To implement a dynamic power management business, various algorithms can optimize the system’s efficiency. 
                            The entire power distribution network can be modeled as a graph, where nodes represent energy sources and consumers, and the edges represent the power transmission lines. 
                            These algorithms help ensure optimal energy flow, reduce waste, and improve overall system reliability.
                        </li>
                        <li>
                            We can utilize Dijkstra's algorithm to optimize the energy distribution routes by finding the shortest path for energy flow, ensuring minimal energy loss and efficient use of resources. 
                            Dijkstra's algorithm is more suitable than Prim's in this case because it focuses on optimizing the shortest and most efficient paths in a network, which is crucial in dynamic power management to maintain a balanced load and reduce power wastage in a complex network with varying demand.
                        </li>
                        <li>
                            In dynamic power management, linked lists and graphs can be effectively used to manage energy distribution and optimize the flow of electricity across the network.
                            <br>
                            ->Linked Lists:
                            <br>
                            A linked list can be used to represent sequences of connected power consumers (such as houses or devices) that need to be powered. Here’s how it can be applied:
                            <br>
                            -Energy consumption tracking: A linked list can be used to store data about power consumption from multiple consumers in a sequence. Each node could represent an individual consumer, holding information such as power usage, location, and demand.
                            <br>
                            -Dynamic allocation of resources: Linked lists allow easy insertion and deletion of consumers, making it a flexible structure to manage energy supply in real-time based on changing demands.
                            <br>
                            ->Graphs:
                            <br>
                            Graphs are a more natural fit for modeling the entire power distribution network, including the relationships between power sources (e.g., power plants or grids) and consumers (e.g., houses, businesses).
                            <br>
                            -Nodes represent the power sources (e.g., power plants, substations) and consumers (e.g., homes, factories).
                            <br>
                            -Edges represent the power transmission lines, connecting power sources to consumers.
                        </li>
                        <li>
                            We can also use <b>sorting algorithms</b> to arrange areas based on their populations, allowing us to strategically place power grids of appropriate sizes. 
                            By sorting areas from highest to lowest population, we can ensure that larger grids are allocated to more densely populated regions, optimizing energy distribution and ensuring that resources are efficiently utilized based on demand. 
                            This approach helps in balancing the load and ensuring reliable power supply to all areas.
                        </li>
                        <li>
                            Spanning Tree Algorithms, such as **Prim’s** or **Kruskal’s**, are used to determine the most cost-effective routes for laying down cables or transmission lines in a power distribution network. 
                            These algorithms help ensure that the infrastructure is built with the least amount of wiring or connections, minimizing costs while maintaining connectivity between all power sources and consumers. 
                            By focusing on connecting all nodes with the minimum possible cost, spanning tree algorithms optimize both the cost of construction and the efficiency of the entire network, reducing unnecessary energy loss and improving the system's overall performance.
                        </li>
                        <li>
                            A <b>look-up table</b> is a data structure that stores pre-calculated values for quick access. 
                            In the context of dynamic power management, it can be used to swiftly retrieve data related to energy consumption patterns of specific consumers or buildings. 
                            By storing energy usage statistics or historical consumption data, the look-up table enables fast decision-making for efficient energy distribution and load balancing, 
                            reducing the need for real-time calculations and enhancing overall system performance.
                        </li>
                        <li>
                            <b>BIT (Binary Indexed Tree)</b>, also known as a **Fenwick Tree**, operates on the concept of isolating the last bit and is highly efficient for range queries. 
                            We prefer BIT over segment trees in dynamic power management because it is easier to implement and requires simpler code. 
                            In this context, BIT can be used to quickly calculate the total energy consumption of a consumer or building over a specific time period, allowing for efficient tracking and adjustments in energy allocation across the network.
                        </li>
                    </ul>
                    <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Prim's Algorithm</b>
                            <p>Prim's Algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) 
                                of a connected, undirected graph with weighted edges<br>
                                Efficiency: O(|E|log|V|)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Prims%20Algorithm" class="code">Sample Code for Prim's Algorithm</a>
                            </p>
                        </li>
                        <li><b>Dijkstra's algorithm</b>
                            <p>Dijkstra's Algorithm is a well-known greedy algorithm used for finding the shortest path 
                                from a source vertex to all other vertices in a weighted graph (where the weights are non-negative).<br>
                                Efficiency: O(|E|log|V|)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Dijkstras%20Algorithm" class="code">Sample Code for Dijkstra's algorithm</a>
                            </p>
                        </li>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to arrange elements in a specific order 
                                (usually in ascending or descending order). <br>
                                Efficiency: <br>
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Lookup table</b>
                            <p>
                                A lookup table is a data structure that is used to store pre-computed values for quick retrieval. <br>
                                Efficiency: O(1)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Lookup-Table" class="code">Sample Code for Lookup table</a>
                            </p>
                        </li>
                        <li><b>BIT or Fenwick tree</b>
                            <p>BIT or Fenwick tree works on the concept of isolating the last bit and is 
                                efficient in processing of range queries. <br>
                                Efficiency: O(log n) <br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Fenwick%20Tree" class="code">Sample Code for BIT</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>

        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Efficient Electricity Distribution:</h2>
                <p class="explain">
                    <ul>
                        <li>
                            As the city aims to become a self-sufficient, sustainable, and developed hub, efficient electricity distribution plays a crucial role in this process. 
                            It is important to design the power grid infrastructure in such a way that electricity is reliably and efficiently delivered to all areas of the city. 
                            This requires strategically placing power grids and transmission lines to ensure easy access to energy for every consumer, regardless of location, 
                            and optimizing the distribution network to meet the growing demands of a developing urban environment.
                        </li>
                        <li>
                           To achieve efficient electricity distribution, we will first analyze the total energy demand from all areas of the city. 
                            This can be done using a <b>basic summation algorithm</b> to calculate the total consumption. 
                            The next step is to prioritize areas based on their energy needs, which can be done using sorting algorithms like <b>quick sort</b> or <b>merge sort</b>. 
                            By sorting regions according to their energy demand, we can strategically allocate resources and place power grids of appropriate sizes, 
                            ensuring that energy distribution is both efficient and meets the requirements of each area.

                        </li>
                        <li>
                            Once we have sorted the areas based on energy demand, we can finalize the locations and capacities of power grids. 
                            The size of each grid will depend on the energy consumption of the area it serves. 
                            Therefore, larger power grids will be placed in more energy-intensive areas, based on the sorted list. 
                            This ensures that regions with higher demand are adequately supplied, optimizing the distribution network and minimizing energy loss, while maintaining a reliable power supply throughout the city.
                        </li>
                        <li>
                            The next step in efficient electricity distribution is to strategically select the locations for power grids and transmission lines, 
                            ensuring that their installation does not harm the environment. Once the grid locations are determined, the next task is to optimize the energy flow, 
                            ensuring that power reaches all areas with minimal loss and maximum efficiency. This can be achieved by implementing advanced algorithms to manage the distribution network, 
                            similar to setting up an efficient transportation service for educational institutions. By considering both environmental impact and energy efficiency, 
                            the system ensures sustainability while meeting the city's growing energy needs.
                        </li>
                        <li>
                            For efficient electricity distribution, we need to design optimal routes for energy flow, ensuring that power is delivered to each consumer in the most cost-effective manner. 
                            This can be achieved using an <b>all-pairs shortest path algorithm like Floyd's algorithm</b>. 
                            We can treat the power grids and consumers as nodes, with the transmission lines as edges, and the cost of energy delivery (e.g., power loss or operational cost) as the weights. 
                            By applying <b>Floyd's algorithm</b> to this graph representation, we can determine the most efficient routes for electricity distribution, minimizing energy loss and optimizing overall system performance.
                        </li>
                        <li>
                            Now that we have strategically placed power grids in key locations to ensure efficient electricity distribution, it is essential to manage the energy supply in an organized manner to ensure smooth and reliable service. 
                            To achieve this, we need to keep a record of each energy consumer and their consumption patterns. This can be done using an <b>array of structures</b> to store details such as consumer ID, address, energy consumption history, 
                            and payment status. This system will help manage the grid's load, track energy usage, and provide insights for optimizing future energy distribution.
                        </li>
                        <li>
                            For managing electricity distribution, we can use a <b>queue data structure</b> to handle requests for energy supply on a first-come, first-served basis. 
                            This ensures that consumers are connected to the grid in the order they request service. Alternatively, we can prioritize areas based on their energy consumption needs using a <b>sorting technique</b>,
                            such as sorting by the highest demand, and then allocate energy resources accordingly. This ensures that areas with higher energy needs are addressed first, optimizing the use of available resources and balancing the load across the network.
                        </li>
                        <li>
                            Other sensitive data regarding electricity consumers, such as their account numbers, billing information, or payment history, can be stored securely using <b>hashing algorithms</b>. 
                            This ensures that sensitive information is encrypted and protected from unauthorized access. 
                            Hashing algorithms provide a secure way to store and retrieve consumer data without exposing the original information,
                            maintaining privacy while allowing efficient access when needed for billing, customer service, or monitoring energy usage.
                        </li>
                    </ul>
                    <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Basic summation algorithm</b>
                            <p>Calculates the sum of all the elements of an Array.
                                Efficiency: O(1)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/blob/d85d72bbe8b0fc7c430c855b9b817b860b716ead/Basic%20Operations/Sum%20of%20elements%20of%20Array.cpp" class="code">Sample Code for Basic summation</a>
                            </p>
                        </li>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to arrange elements 
                                in a specific order (usually in ascending or descending order).<br>
                                Efficiency: 
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Floyd's algorithm</b>
                            <p>The Floyd-Warshall algorithm is an algorithm used to find the shortest paths 
                                between all pairs of nodes in a weighted graph.<br>
                                Efficiency: O(n^3)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Floyds%20Algorithm" class="code">Sample Code for Floyd's algorithm</a>
                            </p>
                        </li>
                        <li><b>Array of structures</b>
                            <p>An array of structures is a collection of multiple structure variables stored sequentially in memory.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/590680d9c376432fa276ad23a0e4fb9afe55d950/Array%20Of%20Structures" class="code">Sample Code for Array of structures</a>
                            </p>
                        </li>
                        <li><b>Queue data structure</b>
                            <p>A queue is a linear data structure that follows the FIFO (First In, First Out) principle. This means that 
                                the element added first will be removed first.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/33727621bd6560be47e0cb784cdc14957225b16d/Queue" class="code">Sample Code for Basic Queue</a>
                            </p>
                        </li>
                        <li><b>Hashing algorithms</b>
                            <p>Hashing algorithms are methods used to map data (such as a string, number, or any type of object) to a fixed-size 
                                value called a hash value.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/33727621bd6560be47e0cb784cdc14957225b16d/Hashing" class="code">Sample Code for Hashing algorithms</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>

        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Energy Storage Optimization:</h2>
                <p class="explain">
                    <ul>
                        <li>
                            <b>Energy Storage Optimization</b> plays a crucial role in managing and distributing energy efficiently. 
                            Various algorithms can be applied to optimize the storage of energy, such as <b>dynamic scheduling algorithms</b> to balance energy supply and demand, 
                            and <b>route optimization algorithms</b> for efficient distribution. These algorithms ensure that energy is stored at optimal times when demand is low 
                            and can be accessed quickly when demand rises, reducing energy loss and minimizing costs. By continuously monitoring and adjusting the storage system, 
                            energy storage optimization contributes to a more reliable and sustainable energy infrastructure.
                        </li>
                        <li>
                            For <b>Energy Storage Optimization</b>, we can use <b>binary search</b> to efficiently search for energy storage devices or resources from a list of available options, 
                            reducing the time needed for retrieval. Additionally, we can apply <b>tries</b> to implement an autocomplete feature when searching for energy consumption patterns, system configurations, 
                            or device specifications, improving user experience. This would help in quickly navigating through large datasets or system configurations related to energy storage, 
                            ensuring more efficient management and retrieval of critical data in real-time.
                        </li>
                        <li>
                            For <b>Energy Storage Optimization</b>, we can use <b>string matching algorithms like KMP and Rabin-Karp</b> to search for specific energy storage devices or configurations in a large database efficiently. 
                            These algorithms can help quickly find relevant information about energy systems or equipment.
                            Next, we can apply <b>sorting algorithms</b> to arrange energy storage options based on criteria such as efficiency, capacity, cost, and energy usage patterns. Additionally, <b>recommendation engines</b>
                            can be utilized to suggest the most suitable energy storage solutions to users based on their past usage patterns or preferences, optimizing the decision-making process for energy management.
                        </li>
                        <li>
                            For </b>Energy Storage Optimization</b>, we can use shortest path algorithms like <b>Dijkstra’s Algorithm</b> to optimize energy distribution routes. 
                            In this case, the storage facility acts as the source node where all the energy is stored, ready for distribution. 
                            The nodes represent various locations, such as homes or businesses, requiring energy, and the edges are the transmission lines connecting them, 
                            with weights representing the cost or efficiency of energy transfer. By applying Dijkstra’s algorithm, 
                            we can ensure that energy is delivered via the most cost-effective and efficient route, minimizing energy loss and optimizing the overall distribution process. 
                        </li>
                        <li>
                          By using <b>sorting algorithms</b>, we can organize energy storage options, customer demand, or delivery priorities based on key factors like energy consumption, location, or urgency. 
                            For example, sorting algorithms like **Quick Sort** or **Merge Sort** can be used to arrange delivery routes by distance, or sort energy storage solutions by capacity and efficiency. 
                            This allows us to prioritize the most critical or high-demand locations for quicker delivery, ensuring that resources are distributed efficiently and in an optimized manner. 
                            Sorting can significantly streamline the decision-making process and enhance the overall efficiency of energy distribution.
                        </li>
                        <li>
                            <b>Arrays and lists</b> can be used for storing energy storage unit data, customer energy usage patterns, delivery schedules, or feedback on energy solutions. 
                            Arrays can store data such as energy consumption records over time, while lists can be used to maintain dynamic data such as ongoing orders or customer feedback.
                            These data structures enable efficient tracking, updating, and retrieval of information, ensuring smooth operation and optimization of energy storage and distribution processes.
                        </li>
                        <li>
                            <b>Stack</b> can be used to track changes in energy consumption or storage configurations, allowing for easy undo actions and facilitating backtracking during the optimization of energy distribution.
                        </li>
                        <li>
                            </b>Union-Find</b> can be used for managing energy distribution networks, helping to efficiently group connected power grids or storage units and track their relationships during optimization tasks.
                        </li>
                    </ul>
                    <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Binary Search</b>
                            <p>Binary Search is an efficient algorithm for finding an item from a sorted list or array. <br>
                                Efficiency:
                                Best case: O(1)<br>
                                Worst case & Avg case: O(log n)<br><br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Binary%20Search" class="code">Sample Code for Binary Search</a>
                            </p>
                        </li>
                        <li><b>String Search:- KMP & Rabin Karp</b>
                            <p>String search algorithms are used to find a substring or pattern inside a string or text.<br>
                                Efficiency:
                                KMP:<br>
                                Best case:<br>
                                Avg case:<br>
                                worst case:<br><br>
                                Rabin Karp:<br>
                                Best case:<br>
                                Avg case:<br>
                                worst case:<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/String%20Search" class="code">Sample Code for String Search</a>
                            </p>
                        </li>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to arrange elements in
                                a specific order (usually in ascending or descending order).<br>
                                Efficiency: <br>
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Recommendation engines</b>
                            <p>A recommendation engine (or recommendation system) is a type of software system that 
                                suggests products, services, or content to users based on their preferences, behavior, or other data. <br><br>
                                <a href="#kruskals" class="code">Sample Code for Recommendation engines</a>
                            </p>
                        </li>
                        <li><b>Trie</b>
                            <p>A Trie is a specialized tree-like data structure used for dealing with applications involving search operations
                                 like autocomplete, dictionary lookups, and spell checking.<br>
                                Efficiency: O(l) where l is length of string.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Trie" class="code">Sample Code for Trie</a>
                            </p>
                        </li>
                        <li><b>Dijkstra's algorithm</b>
                            <p>Dijkstra's Algorithm is a well-known greedy algorithm used for finding the shortest path 
                                from a source vertex to all other vertices in a weighted graph (where the weights are non-negative).<br>
                                Efficiency: O(|E|log|V|)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Dijkstras%20Algorithm" class="code">Sample Code for Dijkstra's algorithm</a>
                            </p>
                        </li>
                        <li><b>Arrays & Lists</b>
                            <p>An array is a collection of elements, typically of the same type, stored in contiguous memory locations. 
                                A list is a more flexible data structure than an array, often allowing for dynamic resizing. Lists can 
                                store elements of different types<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Linked%20List" class="code">Sample Code for Arrays & lists</a>
                            </p>
                        </li>
                        <li><b>Stack</b>
                            <p>A stack is a linear data structure that follows the Last In, First Out (LIFO) principle, meaning the last element added to the stack is the first one to be removed. <br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Stack" class="code">Sample Code for Stack</a>
                            </p>
                        </li>
                        <li><b>Union-Find</b>
                            <p>The Union-Find structure is particularly useful in applications where you need to efficiently manage and query dynamic connectivity, such as in graph algorithms 
                                e.g: Kruskal's Minimum Spanning Tree algorithm and in network connectivity problems.<br>
                                Efficiency: O(n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Unioin-Find" class="code">Sample Code for Union-Find</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>
        </div>
        <br>
    </section>
    <section class="FHcase">
        <h2 class="FHhead">Implemtation With File Handling</h2>
        <div class="FHbox">
            <h2>Education & Vocational Training Centers</h2>
            <ul>
                <li>Calculating Population of each Area<br><br>
                    <a href="https://github.com/AmoghPai19/CityPlan_Indraprasth.gitub.io/tree/3d056a2d1b85387eb12f49d0e7b8da97a1ad2805/Codes%20Using%20File-Handling/Amogh/Educational%20Institutions/PopulationCalc" class="code">Population Calculation</a><br><br>
                </li>
                <li>Sorting the areas based on the population<br><br>
                    <a href="https://github.com/AmoghPai19/CityPlan_Indraprasth.gitub.io/tree/3d056a2d1b85387eb12f49d0e7b8da97a1ad2805/Codes%20Using%20File-Handling/Amogh/Educational%20Institutions/Sorting" class="code">Area Sorting</a><br><br>
                </li>
                <li>Pick-N-Drop Service<br><br>
                    <a href="https://github.com/AmoghPai19/CityPlan_Indraprasth.gitub.io/tree/3d056a2d1b85387eb12f49d0e7b8da97a1ad2805/Codes%20Using%20File-Handling/Amogh/Educational%20Institutions/Pick-N-Drop%20Service" class="code">Route Calculation</a><br><br>

                </li>
                <li>
                    Student Admission<br><br>
                    <a href="https://github.com/AmoghPai19/CityPlan_Indraprasth.gitub.io/tree/3d056a2d1b85387eb12f49d0e7b8da97a1ad2805/Codes%20Using%20File-Handling/Amogh/Educational%20Institutions/Admissions" class="code">Admission Queue</a><br><br>
                </li>
                <li>
                    Student information storage<br><br>
                    <a href="https://github.com/AmoghPai19/CityPlan_Indraprasth.gitub.io/tree/3d056a2d1b85387eb12f49d0e7b8da97a1ad2805/Codes%20Using%20File-Handling/Amogh/Educational%20Institutions/StudentInfo" class="code">Student structure</a><br><br>
                </li>
            </ul>
        </div>
        

    </section>
</body>
</html>
