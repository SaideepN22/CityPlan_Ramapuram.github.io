<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="logo">City Design</div>
        <ul class="nav-links">
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="project.html">Project</a></li>
        </ul>
    </nav>

    <!-- Business Ideas Section -->
    <section class="business-ideas">
        <h2 class="head">Identified Business Ideas</h2>
        <div class="ideas-box">
            
            <div class="idea">
                <h3>Listing all the areas by distance:-</h3>
                <p>
                    <ul>
                        <li>
                            <b>Relevance to SDG 7:</b> Listing all areas by distance facilitates targeted and sustainable energy distribution.
                        </li>
                        <li>
                            This business idea focuses on utilizing data analytics and machine learning to monitor and predict electricity demand in various areas based on their distance from power sources. 
                            Accurate forecasting and efficient distance-based prioritization enable utility companies to optimize energy distribution, enhance grid stability, and reduce the likelihood of blackouts, contributing to a more reliable and sustainable power supply system.
                        </li>
                    </ul>
                </p>
            </div>

            <div class="idea">
                <h3>Renewable Energy Integration:</h3>
                <p>
                    <ul>
                        <li>
                            <b>Relevance to SDG 7:</b> Promoting the use of renewable energy sources reduces reliance on fossil fuels, leading to cleaner energy systems.
                        </li>
                        <li>
                            This idea focuses on integrating renewable energy (solar, wind, etc.) into the existing power grid. It could involve designing smart grid systems or microgrids that manage the variability of renewables while ensuring consistent energy supply to consumers.
                        </li>
                    </ul>
                </p>
            </div>

            <div class="idea">
                <h3>Energy Efficiency Management:</h3>
                <p>
                    <ul>
                        <li>
                            <b>Relevance to SDG 7:</b> Energy efficiency is critical to reducing energy consumption and associated costs while minimizing environmental impact.
                        </li>
                        <li>
                            This business idea revolves around technologies or strategies to optimize energy use in homes, businesses, and industries. Examples include energy-efficient appliances, smart meters, and AI-driven systems that detect and eliminate energy wastage.
                        </li>
                    </ul>
                </p>
            </div>
            
        </div>
    </section>

    <!-- Reflection Section -->
    <section class="Reflection">
        <h2>Course  Learning Reflections</h2>
        <div class="reflection-box">
            <ol>
                <li>
                    What are the kinds of problems we see in nature? (iteration, recursion, backtracking)
                    <p class="ans">
                        In nature, we can see problems being solved in ways similar to computational techniques like iteration, recursion, and backtracking. 
                        For example, iteration shows up in things like the repeating cycles of seasons or the rise and fall of predator-prey populations. 
                        Recursion is easy to spot in patterns like snowflakes, the way trees branch out, or how rivers split into smaller streams—all of them repeating the same shapes on different scales. 
                        Backtracking happens when animals, like ants or rats, try one path to find food, hit a dead end, and go back to try another. 
                        Nature uses these methods to adapt, solve problems, and make things work efficiently.
                    </p>
                </li>
                <li>
                    What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.
                    <p class="ans">
                        Space and time efficiency refer to how much memory it uses as the input size grows and how fast an algorithm runs. 
                        Time efficiency ensures the program runs quickly, while space efficiency focuses on saving memory, which is especially important in resource-limited environments. 
                        The different class of problem can be represented in form of graph as follows:
                        <br>
                            O(1): constant order of growth 
                        <br>
                            O(n): linear order of growth 
                        <br>
                            O(log n): logarithmic order of growth 
                        <br>
                            O(nlogn): Runtime increases more than linear but less than quadratic with input size.
                        <br>
                            O(n2): Runtime increases quadratically.
                        <br>
                            O(n3): Runtime increases cubic.
                        <br>
                            O(2^n): The runtime grows exponentially.
                        <br>
                            O(n!): The runtime grows extremely fast.
                    </p>
                </li>
                <li>
                    Take away from different design principles from chapter 2?
                    <p class="ans">
                        The key takeaway from the design principles is how simple strategies can make complex problems more manageable and algorithms more efficient. 
                        By using principles like decomposition, pattern recognition, and abstraction, we break down tasks into smaller parts. 
                        Techniques like pruning (in N-queens) and lazy propagation (in segment trees) optimize resource use, eliminating unnecessary steps or delaying updates until needed. 
                        Hierarchical order (in BST) and level order traversal (in BFS) help us process data effectively. 
                        Pre-computing results, like in lookup tables, simplifies repeated operations. 
                        Using parental dominance in heaps and bit manipulation in Fenwick trees speeds up calculations. 
                        Finally, DFS and BFS teach us to navigate graphs with careful traversal. 
                        All these principles combine to create more efficient algorithms.
                    </p>
                </li>
                <li>
                    The hierarchical data and how different tree data structures solve and optimize over problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)
                    <p class="ans">
                        Tree data structures are essential for organizing hierarchical data and optimizing operations like searching, sorting, and indexing. 
                        A general tree provides flexibility for generic hierarchies but lacks efficiency. 
                        Binary trees are foundational but can become inefficient if unbalanced. 
                        Self-balancing trees like AVL and Red-Black trees ensure \(O(\log n)\) operations, with AVL trees being more strictly balanced and Red-Black trees easier to maintain during frequent updates. 
                        Heaps are ideal for priority-based tasks (e.g., scheduling), while Tries excel in prefix searches and string operations, such as autocompletion. 
                        Multiway trees like 2-3 trees offer consistent balancing, making them perfect for databases and file systems. 
                        Each structure is tailored to specific scenarios, balancing trade-offs between speed, complexity, and memory usage.
                    </p>
                </li>
                <li>
                    The need for array query algorithms and their implications. Their applications and principles need to be discussed.
                    <p class="ans">
                        Array query algorithms are essential for quickly answering questions about data, such as range sums, maximum values, or patterns, especially in large datasets. 
                        They balance preprocessing, memory usage, and query speed to handle real-time applications like databases, gaming, analytics, and machine learning. 
                        Techniques like prefix sums, Fenwick trees, segment trees, and sliding windows are widely used to optimize operations, ensuring fast responses and efficient updates. 
                        These algorithms are foundational for modern systems where scalability and performance are critical.
                    </p>
                </li>
                <li>
                    Differentiate between tree and graphs and their traversals. The applications of each.
                    <p class="ans">
                        Tree <br>
                        -A connected, acyclic graph with n nodes and n-1 edges. <br>
                        -always has a root node. <br>
                        -always connected. <br>
                        -no cycles. <br>
                        
                       <br> Graphs <br>
                        -Collection of vertices connected by edges, cyclic and even disconnected. <br>
                        -no specific root unless mentioned. <br>
                        -can be connected or disconnected. <br>
                        -have cycles. <br>
                        
                        <br> Tree traversals <br>
                        1. Pre order: Root,Left,Right <br>
                        2. In order: Left, Root, Right <br>
                        3. Post order: Left, Right, Root <br>
                        <br> Eg: heap, BST for search, insert, delete <br>
                        
                        <br> Graph Traversals <br>
                       <br> DFS: traverse as deep as possible before backtracking. <br>
                         Eg: Road maps, Invitation problem. <br>
                        
                       <br> BFS: visit all neighbour nodes before moving. <br>
                        Eg: Networks (social networks)
                    </p>
                </li>
                <li>
                    Deliberate on sorting and searching algorithms, the technique behind each and how they connect to the real world.
                    <p class="ans">
                        Sorting and searching algorithms are vital for organizing and retrieving data efficiently. 
                        Sorting arranges data in a specific order, using techniques like quicksort for speed or counting sort for specific cases, while searching locates items, with binary search excelling on sorted datasets. 
                        These algorithms power real-world applications like search engines, e-commerce filters, and route planning, ensuring quick and reliable results. 
                        Together, they enable efficient data handling, forming the backbone of modern systems like databases, AI, and analytics.
                    </p>
                </li>
                <li>
                    Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.
                    <p class="ans">
                        Graph algorithms, especially for spanning trees and shortest paths, are essential for optimizing real-world systems like networks, navigation, and logistics. 
                        Spanning tree algorithms help efficiently connect all nodes with minimal cost, making them crucial for network design and broadcasting. 
                        Shortest path algorithms, like Dijkstra’s, are used to find the fastest or most cost-effective route, impacting applications like GPS navigation, data routing, and supply chain management. 
                        Together, these algorithms ensure efficient and cost-effective connectivity in fields like telecommunications, transportation, and resource management.
                    </p>
                </li>
                <li>
                    Discuss the different studied algorithm design techniques.
                    <p class="ans">
                        In class, we explored several design techniques, starting with backtracking, where we solved problems like the n-queens and subset generation by considering all possibilities and eliminating unnecessary ones. 
                        We also learned about transform and conquer with AVL trees, heaps, and 2-3 trees. 
                        Moving on to decrease and conquer, we studied graph traversals like BFS and DFS. 
                        We covered divide and conquer through sorting algorithms and string matching techniques, including the Boyer-Moore algorithm, which uses space and time trade-offs. 
                        Finally, we explored greedy algorithms, such as Prim’s, Kruskal’s, and Dijkstra’s, to find the shortest path in weighted graphs.
                    </p>
                </li>
            </ol>
        </div>
    </section>

        <section class="case-breakdown">
        <h2 class="breakdown-head">Detailed Breakdown Of Business Ideas</h2>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Listing all the areas by distance:-</h2>
                <p class="explain">
                    <ul>
                        <li>
                            Ensuring efficient power management by listing all areas by distance is crucial for a growing city, 
                            as it supports sustainable energy distribution and reduces transmission losses, promoting eco-friendly development.
                        </li>
                        <li>
                            To implement a dynamic power management system, areas can be prioritized based on their distances from power sources. 
                            By modeling the network as a graph, where nodes represent areas and edges represent transmission lines, algorithms can optimize energy flow, 
                            minimize losses over long distances, and ensure reliable power distribution to closer areas first, enhancing system efficiency.
                        </li>
                        <li>
                            We can utilize Dijkstra's algorithm to prioritize areas by their distance from power sources, ensuring efficient energy allocation with minimal loss. 
                            Dijkstra's algorithm is more suitable than Prim's in this case as it identifies the shortest and most effective routes for power distribution. 
                            This approach is crucial for maintaining balanced energy supply, especially when managing a network that prioritizes areas based on proximity and varying demand levels.    
                        </li>
                        <li>
                            In , Listing all areas by distance linked lists and graphs can be effectively used to manage energy distribution and optimize the flow of electricity across the network.
                            <br>
                            ->Linked Lists:
                            <br>
                                Linked lists can represent sequences of areas organized by their distance from power sources. Here’s how they apply:
                            <br>
                                Distance-based tracking: A linked list can store areas in increasing order of their distance from a power source. 
                                Each node represents an area with data such as distance, power demand, and priority level.
                            <br>
                            -Dynamic allocation of resources:  Linked lists enable efficient addition or removal of areas in real-time, ensuring flexibility to manage energy distribution as new areas are prioritized based on updated distances.
                            <br>
                            ->Graphs:
                            <br>
                            Graphs are ideal for modeling the power distribution network, with a focus on distance-based relationships between sources and areas.
                            <br>
                            -Each node symbolizes either a power source (e.g., substations) or an area (e.g., cities or neighborhoods).
                            <br>
                            -Edges connect nodes, with weights representing the distances between them. This helps in finding optimal routes for energy delivery based on shortest distance.
                        </li>
                        <li>
                                We can also use sorting algorithms to arrange areas based on their distances from power sources, allowing us to prioritize energy distribution effectively.
                                By sorting areas from nearest to farthest, we can ensure that energy reaches closer areas first, reducing transmission losses and optimizing resource utilization.
                                This approach helps in balancing energy delivery, minimizing power wastage, and ensuring reliable electricity supply to all areas, starting with those that can be serviced most efficiently.
                                Sorting by distance ensures systematic planning and enhances overall power grid efficiency, aligning with sustainable energy management practices.
                        </li>
                        <li>
                            Spanning Tree Algorithms, such as Prim’s or Kruskal’s, can be used to determine the most cost-effective routes for distributing energy based on distance.
                            These algorithms help ensure that electricity is efficiently routed to areas with the shortest distance from power sources, minimizing transmission losses and reducing infrastructure costs.
                            By focusing on connecting all areas with the minimum possible distance, spanning tree algorithms optimize both the cost of laying down transmission lines and the efficiency of energy distribution, ensuring reliable power supply to all areas.
                            This approach also enhances system performance, ensuring that energy reaches consumers with the least energy loss and within the most efficient route.
                        </li>
                        <li>
                            A look-up table can be used to store pre-calculated values related to the distance between various areas and power sources.
                            In the context of dynamic power management based on distance, the look-up table can quickly retrieve the optimal routing information for energy distribution.
                            By storing distance-based data for each area or consumer, the look-up table enables efficient energy routing decisions and load balancing across areas, minimizing transmission losses.
                            This approach reduces the need for real-time distance calculations, improving system performance and ensuring that energy is distributed to the right areas in the most efficient manner.
                        </li>
                        <li>
                            BIT (Binary Indexed Tree), also known as a Fenwick Tree, is efficient for managing range queries and optimizing energy distribution across areas based on distance.
                            In this context, BIT can be used to calculate the total energy demand of areas within a specific distance range from power sources, enabling fast adjustments and efficient energy allocation.
                            By utilizing BIT, we can track and update the energy demand of each area, ensuring that areas closer to power sources receive energy in the most efficient manner.
                            The simplicity of BIT implementation makes it ideal for dynamic power management, enabling quick calculations and adjustments without overcomplicating the system.
                        </li>
                    </ul>
                    <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Prim's Algorithm</b>
                            <p>Prim's Algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) 
                                of a connected, undirected graph with weighted edges<br>
                                Efficiency: O(|E|log|V|)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Prims%20Algorithm" class="code">Sample Code for Prim's Algorithm</a>
                            </p>
                        </li>
                        <li><b>Dijkstra's algorithm</b>
                            <p>Dijkstra's Algorithm is a well-known greedy algorithm used for finding the shortest path 
                                from a source vertex to all other vertices in a weighted graph (where the weights are non-negative).<br>
                                Efficiency: O(|E|log|V|)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Dijkstras%20Algorithm" class="code">Sample Code for Dijkstra's algorithm</a>
                            </p>
                        </li>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to arrange elements in a specific order 
                                (usually in ascending or descending order). <br>
                                Efficiency: <br>
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Lookup table</b>
                            <p>
                                A lookup table is a data structure that is used to store pre-computed values for quick retrieval. <br>
                                Efficiency: O(1)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Lookup-Table" class="code">Sample Code for Lookup table</a>
                            </p>
                        </li>
                        <li><b>BIT or Fenwick tree</b>
                            <p>BIT or Fenwick tree works on the concept of isolating the last bit and is 
                                efficient in processing of range queries. <br>
                                Efficiency: O(log n) <br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Fenwick%20Tree" class="code">Sample Code for BIT</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>

        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Renewable Energy Integration:</h2>
                <p class="explain">
                    <ul>
                        <li>
                           As the city strives to become a self-sufficient, sustainable, and developed hub, efficient distribution of renewable energy plays a pivotal role in this transformation. 
                            It is crucial to design the power grid infrastructure in a way that integrates renewable energy sources—such as solar, wind, and hydropower—ensuring they are reliably and efficiently distributed across the city. 
                            Strategically placing renewable energy sources and transmission lines to provide easy access for every consumer, regardless of location, is key. 
                            By optimizing the grid to prioritize renewable energy integration, we can meet the growing demands of a developing urban environment while reducing the city's reliance on non-renewable energy sources.
                        </li>
                        <li>
                           To achieve efficient electricity distribution, we will first analyze the total energy demand from all areas of the city, factoring in the contribution from renewable energy sources. 
                            This can be done using a basic summation algorithm to calculate the total consumption, including both conventional and renewable energy inputs. 
                            The next step is to prioritize areas based on their energy needs, with special emphasis on integrating renewable energy sources. 
                            This can be done using sorting algorithms like quick sort or merge sort. By sorting regions according to their total energy demand, including renewable contributions, we can strategically allocate resources, 
                            place renewable energy grids (such as solar or wind farms), and optimize power transmission, ensuring that energy distribution is both efficient and sustainable across the city.
                        </li>
                        <li>
                            Once we have sorted the areas based on energy demand, factoring in both conventional and renewable energy sources, we can finalize the locations and capacities of power grids. 
                            The size of each grid will depend not only on the energy consumption of the area but also on the availability and capacity of renewable energy sources like solar, wind, and hydro. 
                            Therefore, larger power grids, which can accommodate renewable energy generation, will be placed in areas with higher energy demand and suitable conditions for renewable energy generation,
                            based on the sorted list. This ensures that regions with higher demand are adequately supplied by a mix of conventional and renewable sources, optimizing the distribution network, reducing carbon emissions, and minimizing energy loss while maintaining a reliable and sustainable power supply throughout the city.
                         </li>
                        <li>
                            The next step in efficient electricity distribution is to strategically select the locations for power grids and renewable energy sources (like solar panels, wind turbines, etc.) and transmission lines, 
                            ensuring that their installation minimizes environmental impact. Once the grid locations and renewable energy sources are determined, the next task is to optimize the energy flow, ensuring that both conventional and renewable power reaches 
                            all areas with minimal loss and maximum efficiency. This can be achieved by implementing advanced algorithms that manage the distribution network, allowing for dynamic adjustments based on renewable energy generation fluctuations. 
                            By considering both environmental sustainability and energy efficiency, the system ensures that the city’s growing energy needs are met in a way that reduces dependency on non-renewable resources and supports the integration of renewable energy into the grid, contributing to the city’s long-term sustainability.
                        </li>
                        <li>
                             For efficient electricity distribution with a focus on renewable energy integration, we need to design optimal routes for energy flow, ensuring that power from both renewable and conventional sources is delivered to each consumer in the most cost-effective manner. This can be achieved using an all-pairs shortest path algorithm like Floyd's algorithm. We can treat the renewable energy sources, power grids, and consumers as nodes, with the transmission lines as edges, and the cost of energy delivery (including power loss, renewable energy integration costs, or operational costs) as the weights. By applying Floyd's algorithm to this graph representation, we can determine the most efficient routes for electricity distribution, minimizing energy loss, accommodating fluctuations in renewable energy generation, and optimizing the overall system’s performance. 
                            This approach ensures that renewable energy is effectively integrated into the grid and distributed efficiently to meet the city’s growing demand for sustainable power.
                        </li>
                        <li>
                            Now that we have strategically placed power grids in key locations to ensure efficient electricity distribution, it is essential to manage the energy supply in an organized manner to ensure smooth and reliable service, particularly when integrating renewable energy sources. To achieve this, we need to keep a record of each energy consumer and their consumption patterns, including the amount of renewable energy used. This can be done using an array of structures to store details such as consumer ID, address, energy consumption history (with renewable energy breakdown), payment status, and the renewable energy contribution (solar, wind, etc.). This system will help manage the grid's load, track both conventional and renewable energy usage, and provide insights for optimizing future energy distribution. 
                            By maintaining detailed records, we can balance the grid's supply and demand, ensure efficient use of renewable energy, and make adjustments to improve sustainability in the long term.
                        </li>
                        <li>
                            For managing electricity distribution, we can use a queue data structure to handle requests for energy supply on a first-come, first-served basis. This ensures that consumers are connected to the grid in the order they request service. However, when integrating renewable energy, we can also prioritize areas based on their renewable energy generation capacity (e.g., solar or wind) and their current energy demand. This can be achieved by using a sorting technique, such as sorting by the highest renewable energy potential, followed by sorting by consumption demand. This approach ensures that areas with higher renewable energy production are utilized effectively, reducing dependency on non-renewable sources and optimizing the use of available green energy. 
                            This also helps balance the load across the network while prioritizing sustainability and reducing energy waste.
                        </li>
                        <li>
                            Other sensitive data regarding electricity consumers, such as their renewable energy usage patterns, solar panel installations, or wind turbine data, can be stored securely using hashing algorithms. This ensures that sensitive information related to renewable energy production and consumption is encrypted and protected from unauthorized access. Hashing algorithms provide a secure way to store and retrieve data about renewable energy installations, usage history, and efficiency, without exposing the original information. This maintains privacy while allowing efficient access when needed for managing energy distribution, optimizing renewable energy integration, or monitoring sustainability goals.
                        </li>
                    </ul>
                    <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Basic summation algorithm</b>
                            <p>Calculates the sum of all the elements of an Array.
                                Efficiency: O(1)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/blob/d85d72bbe8b0fc7c430c855b9b817b860b716ead/Basic%20Operations/Sum%20of%20elements%20of%20Array.cpp" class="code">Sample Code for Basic summation</a>
                            </p>
                        </li>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to arrange elements 
                                in a specific order (usually in ascending or descending order).<br>
                                Efficiency: 
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Floyd's algorithm</b>
                            <p>The Floyd-Warshall algorithm is an algorithm used to find the shortest paths 
                                between all pairs of nodes in a weighted graph.<br>
                                Efficiency: O(n^3)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Floyds%20Algorithm" class="code">Sample Code for Floyd's algorithm</a>
                            </p>
                        </li>
                        <li><b>Array of structures</b>
                            <p>An array of structures is a collection of multiple structure variables stored sequentially in memory.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/590680d9c376432fa276ad23a0e4fb9afe55d950/Array%20Of%20Structures" class="code">Sample Code for Array of structures</a>
                            </p>
                        </li>
                        <li><b>Queue data structure</b>
                            <p>A queue is a linear data structure that follows the FIFO (First In, First Out) principle. This means that 
                                the element added first will be removed first.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/33727621bd6560be47e0cb784cdc14957225b16d/Queue" class="code">Sample Code for Basic Queue</a>
                            </p>
                        </li>
                        <li><b>Hashing algorithms</b>
                            <p>Hashing algorithms are methods used to map data (such as a string, number, or any type of object) to a fixed-size 
                                value called a hash value.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/33727621bd6560be47e0cb784cdc14957225b16d/Hashing" class="code">Sample Code for Hashing algorithms</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>

        </div>
        <br>
        <div class="beakdown-box">
            <div class="cases">
                <h2 class="case-head">Energy Efficiency Management:</h2>
                <p class="explain">
                    <ul>
                        <li>
                            Energy Efficiency Management is essential for optimizing energy consumption across various sectors and reducing overall demand. By applying advanced dynamic scheduling algorithms, energy distribution can be balanced to ensure that energy is consumed efficiently during peak and off-peak hours. Optimization algorithms can monitor and adjust usage patterns, ensuring minimal waste and maximum utility. These algorithms help identify areas with high energy inefficiencies, enabling targeted actions for reducing consumption. 
                            By focusing on consumption reduction and resource conservation, Energy Efficiency Management contributes to a more sustainable and eco-friendly energy infrastructure.
                        </li>
                        <li>
                            For Energy Efficiency Management, we can use binary search to efficiently identify areas or devices with high energy consumption from a list of monitored resources, reducing the time needed to pinpoint inefficiencies. Additionally, we can apply tries to implement an autocomplete feature when searching for energy consumption data, usage patterns, or system settings, enhancing user experience. This would streamline the process of analyzing large datasets related to energy usage, 
                            enabling quicker decision-making for optimizing energy allocation, reducing waste, and ensuring that energy resources are used effectively across the network.
                        </li>
                        <li>
                            For <b>Energy Storage Optimization</b>, we can use <b>string matching algorithms like KMP and Rabin-Karp</b> to search for specific energy storage devices or configurations in a large database efficiently. 
                            These algorithms can help quickly find relevant information about energy systems or equipment.
                            Next, we can apply <b>sorting algorithms</b> to arrange energy storage options based on criteria such as efficiency, capacity, cost, and energy usage patterns. Additionally, <b>recommendation engines</b>
                            can be utilized to suggest the most suitable energy storage solutions to users based on their past usage patterns or preferences, optimizing the decision-making process for energy management.
                        </li>
                        <li>
                            For Energy Efficiency Management, we can use shortest path algorithms like Dijkstra’s Algorithm to optimize energy distribution routes while ensuring maximum energy efficiency. In this case, the energy-efficient systems act as the source nodes where energy is stored or generated, ready for distribution. The nodes represent different consumers, such as homes, industries, or buildings, requiring energy, and the edges represent the transmission lines or smart grids connecting them, with weights indicating the energy consumption, cost, or efficiency of energy transfer. By applying Dijkstra’s algorithm, we can determine the most efficient and cost-effective routes for energy flow, 
                            ensuring reduced energy waste, improving load management, and enhancing the sustainability of the entire distribution network.
                         </li>
                        <li>
                             By using sorting algorithms, we can organize energy efficiency data, consumer demand, or system priorities based on key factors like energy usage patterns, location, or urgency. For example, sorting algorithms like Quick Sort or Merge Sort can be employed to arrange energy consumption patterns by peak demand times, sort energy-efficient appliances by performance, or organize smart grid zones by energy conservation potential. 
                            This helps prioritize areas with higher efficiency needs or critical energy-saving goals, ensuring that resources are allocated optimally for reducing overall consumption. Sorting can significantly streamline decision-making, helping maximize energy savings and improve system efficiency in a sustainable manner.
                        </li>
                        <li>
                            Arrays and lists can be used to store energy efficiency data, customer usage trends, optimization schedules, or feedback on energy-saving solutions. Arrays can store historical energy consumption data, while lists can maintain real-time data such as active energy-saving projects or customer feedback on energy conservation efforts. These data structures facilitate efficient tracking, updating, and retrieval of information, ensuring smooth operation and continuous optimization of energy usage, efficiency measures, and distribution processes. This helps in better managing the resources and ensuring that the most efficient energy-saving strategies are implemented in real-time.
                        </li>
                        <li>
                            Stack can be used to track changes in energy optimization configurations or adjustments made to energy consumption plans, allowing for easy rollback actions. This ensures that during the process of optimizing energy distribution, any changes can be reversed quickly, facilitating efficient backtracking and refining strategies to improve energy efficiency. 
                            The stack structure helps maintain a record of previous configurations, enabling quick comparisons and ensuring that the most optimal energy-saving measures are applied.
                        </li>
                        <li>
                            Union-Find can be used for managing energy distribution networks by efficiently grouping interconnected power grids, energy storage units, and consumers. This data structure helps track their relationships during optimization tasks, allowing us to identify and manage connected components within the network. By applying Union-Find, we can streamline the process of optimizing energy flow and ensure that energy distribution is balanced across different clusters of consumers and power sources, improving the overall efficiency of the energy management system.
                        </li>
                    </ul>
                    <h3>Algorithms/Data-structures Used:</h3>
                    <ul>
                        <li><b>Binary Search</b>
                            <p>Binary Search is an efficient algorithm for finding an item from a sorted list or array. <br>
                                Efficiency:
                                Best case: O(1)<br>
                                Worst case & Avg case: O(log n)<br><br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Binary%20Search" class="code">Sample Code for Binary Search</a>
                            </p>
                        </li>
                        <li><b>String Search:- KMP & Rabin Karp</b>
                            <p>String search algorithms are used to find a substring or pattern inside a string or text.<br>
                                Efficiency:
                                KMP:<br>
                                Best case:<br>
                                Avg case:<br>
                                worst case:<br><br>
                                Rabin Karp:<br>
                                Best case:<br>
                                Avg case:<br>
                                worst case:<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/String%20Search" class="code">Sample Code for String Search</a>
                            </p>
                        </li>
                        <li><b>Sorting Algorithms:- Quick Sort, Merge Sort, Heap Sort</b>
                            <p>Sorting algorithms are fundamental algorithms used to arrange elements in
                                a specific order (usually in ascending or descending order).<br>
                                Efficiency: <br>
                                Quick Sort:<br>
                                Best case: O(n log n)<br>
                                Avg case: O(1.38n log n)<br>
                                Worst case: O(n^2)<br><br>

                                Merge Sort:O(n log n)<br><br>

                                Heap Sort: O(n log n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/15ad034f96929e76cc3b17727a5a62f53c38fed9/Sorting%20Alogithms" class="code">Sample Code for Sorting Algorithms</a>
                            </p>
                        </li>
                        <li><b>Recommendation engines</b>
                            <p>A recommendation engine (or recommendation system) is a type of software system that 
                                suggests products, services, or content to users based on their preferences, behavior, or other data. <br><br>
                                <a href="#kruskals" class="code">Sample Code for Recommendation engines</a>
                            </p>
                        </li>
                        <li><b>Trie</b>
                            <p>A Trie is a specialized tree-like data structure used for dealing with applications involving search operations
                                 like autocomplete, dictionary lookups, and spell checking.<br>
                                Efficiency: O(l) where l is length of string.<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Trie" class="code">Sample Code for Trie</a>
                            </p>
                        </li>
                        <li><b>Dijkstra's algorithm</b>
                            <p>Dijkstra's Algorithm is a well-known greedy algorithm used for finding the shortest path 
                                from a source vertex to all other vertices in a weighted graph (where the weights are non-negative).<br>
                                Efficiency: O(|E|log|V|)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Dijkstras%20Algorithm" class="code">Sample Code for Dijkstra's algorithm</a>
                            </p>
                        </li>
                        <li><b>Arrays & Lists</b>
                            <p>An array is a collection of elements, typically of the same type, stored in contiguous memory locations. 
                                A list is a more flexible data structure than an array, often allowing for dynamic resizing. Lists can 
                                store elements of different types<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Linked%20List" class="code">Sample Code for Arrays & lists</a>
                            </p>
                        </li>
                        <li><b>Stack</b>
                            <p>A stack is a linear data structure that follows the Last In, First Out (LIFO) principle, meaning the last element added to the stack is the first one to be removed. <br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Stack" class="code">Sample Code for Stack</a>
                            </p>
                        </li>
                        <li><b>Union-Find</b>
                            <p>The Union-Find structure is particularly useful in applications where you need to efficiently manage and query dynamic connectivity, such as in graph algorithms 
                                e.g: Kruskal's Minimum Spanning Tree algorithm and in network connectivity problems.<br>
                                Efficiency: O(n)<br><br>
                                <a href="https://github.com/AmoghPai19/DSA_CodeLibrary/tree/6bb8c79b6e3d3196b19112dabe9c370c4491ec8c/Unioin-Find" class="code">Sample Code for Union-Find</a>
                            </p>
                        </li>
                    </ul>
                </p>
            </div>
        </div>
        <br>
    </section>    
</body>
</html>
